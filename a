TREES
1. Recover BST
import java.util.Stack;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {}

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public void recoverbst(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        TreeNode lastProcessed = null;
        TreeNode[] swapped = new TreeNode[2];

        while (!stack.isEmpty() || current != null) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            current = stack.pop();
            if (lastProcessed != null && lastProcessed.val > current.val) {
                if (swapped[0] == null) {
                    swapped[0] = lastProcessed;
                    swapped[1] = current;
                } else {
                    swapped[1] = current;
                    break;
                }
            }
            lastProcessed = current;
            current = current.right;
        }
    }
}

public class Recover_BST {
    public static void main(String args[]) {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(1);
        root.right = new TreeNode(4);
        root.right.left = new TreeNode(2);

        Solution solution = new Solution();
        solution.recoverbst(root);

        printInorder(root);
    }

    static void printInorder(TreeNode node) {
        if (node == null) {
            return;
        }
        printInorder(node.left);
        System.out.println(" " + node.val);
        printInorder(node.right);
    }
}

2. Views of a tree
import java.util.*;
import java.util.Map.Entry;

class Node {
    int data, hd;
    Node left, right;

    public Node(int data) {
        this.data = data;
        left = right = null;
        this.hd = Integer.MAX_VALUE;
    }
}

public class Views_of_a_Tree {

    static Node root;
    private List<Integer> path1 = new ArrayList<>();
    private List<Integer> path2 = new ArrayList<>();

    static Node build(String s[]) {
        if (s[0].equals("N") || s.length == 0) {
            return null;
        }

        Node root = new Node(Integer.parseInt(s[0]));
        Queue<Node> q = new LinkedList<Node>();
        q.add(root);
        int i = 1;

        while (!q.isEmpty() && i < s.length) {
            Node curr = q.poll();

            String cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.left = new Node(h);
                q.add(curr.left);
            }
            i++;

            if (i >= s.length) {
                break;
            }

            cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.right = new Node(h);
                q.add(curr.right);
            }
            i++;
        }
        return root;
    }

    // Right View
    void rightView(Node root) {
        if (root == null) {
            return;
        }

        Queue<Node> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            int n = q.size();
            for (int i = 0; i < n; i++) {
                Node curr = q.peek();
                q.remove();
                if (i == n - 1) {
                    System.out.println(curr.data + " ");
                }

                if (curr.left != null) {
                    q.add(curr.left);
                }

                if (curr.right != null) {
                    q.add(curr.right);
                }
            }
        }
    }

    // Left View
    void leftView(Node root) {
        if (root == null) {
            return;
        }

        Queue<Node> q = new LinkedList<>();
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            for (int i = 1; i <= n; i++) {
                Node curr = q.poll();

                if (i == 1) {
                    System.out.print(curr.data + " ");
                }

                if (curr.left != null) {
                    q.add(curr.left);
                }

                if (curr.right != null) {
                    q.add(curr.right);
                }
            }
        }
    }

    // Top View
    static class QueueObj {
        Node node;
        int hd;

        QueueObj(Node node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }

    static void topView(Node root) {
        if (root == null) {
            return;
        }

        Queue<QueueObj> q = new LinkedList<>();
        Map<Integer, Integer> map = new HashMap<>();
        int min = 0;
        int max = 0;

        q.add(new QueueObj(root, 0));
        while (!q.isEmpty()) {
            QueueObj curr = q.poll();

            if (!map.containsKey(curr.hd)) {
                map.put(curr.hd, curr.node.data);
            }

            if (curr.node.left != null) {
                min = Math.min(min, curr.hd - 1);
                q.add(new QueueObj(curr.node.left, curr.hd - 1));
            }

            if (curr.node.right != null) {
                max = Math.max(max, curr.hd + 1);
                q.add(new QueueObj(curr.node.right, curr.hd + 1));
            }
        }

        for (; min <= max; min++) {
            System.out.print(map.get(min) + " ");
        }
    }

    // Bottom View
    static void bottomView(Node root) {
        if (root == null) {
            return;
        }

        int hd = 0;

        Map<Integer, Integer> map = new TreeMap<>();
        Queue<Node> queue = new LinkedList<Node>();
        root.hd = hd;
        queue.add(root);

        while (!queue.isEmpty()) {
            Node temp = queue.remove();
            hd = temp.hd;
            map.put(hd, temp.data);

            if (temp.left != null) {
                temp.left.hd = hd - 1;
                queue.add(temp.left);
            }

            if (temp.right != null) {
                temp.right.hd = hd + 1;
                queue.add(temp.right);
            }
        }

        for (int value : map.values()) {
            System.out.print(value + " ");
        }
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        Views_of_a_Tree ob = new Views_of_a_Tree();
        String s[] = sc.nextLine().split(" ");
        root = build(s);
        ob.rightView(root);
        System.out.println();
        ob.leftView(root);
        System.out.println();
        topView(root);
        System.out.println();
        bottomView(root);
    }
}

3.Dials Algo
import java.util.*;

public class Dials_Algo {
    static final int INF = Integer.MAX_VALUE;
    private int V;
    private ArrayList<ArrayList<Tuple>> adj;

    public Dials_Algo(int v) {
        this.V = v;
        this.adj = new ArrayList<ArrayList<Tuple>>();
        for (int i = 0; i < v; i++)
            this.adj.add(new ArrayList<Tuple>());
    }

    public void AddEdge(int u, int v, int w) {
        adj.get(u).add(new Tuple(v, w));
        adj.get(v).add(new Tuple(u, w));
    }

    public void shortestPath(int src, int W){
        int[] dist = new int[V];
        Arrays.fill(dist, INF);

        ArrayList<Integer>[] B = new ArrayList[W * V + 1];
        for(int i = 0; i < W * V + 1; i++){
            B[i] = new ArrayList<Integer>();
        }
        B[0].add(src);
        dist[src] = 0;
        int idx = 0;

        while(true){
            while (B[idx].size() == 0 && idx < W * V){
                idx ++;
            }

            if (idx == W * V){
                break;
            }

            int u = B[idx].get(0);
            B[idx].remove(0);

            for(Tuple i : adj.get(u)){
                int v = i.v;
                int weight = i.w;
                int du = dist[u];
                int dv = dist[v];
                if(dv > du + weight){
                    dist[v] = du + weight;
                    dv = dist[v];
                    B[dv].add(0, v);
                }
            }
        }

        System.out.println("Vertex Distance from Source");
        for (int i = 0; i < V; ++i)
            System.out.println(i + "\t\t" + dist[i]);
    }

    static class Tuple{
        int v, w;

        Tuple(int v, int w){
            this.v = v;
            this.w = w;
        }
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int V = s.nextInt();
        Dials_Algo g = new Dials_Algo(V);
        int e = s.nextInt();
        int st, en, d;

        for (int i = 0; i < e; i++) {
            st = s.nextInt();
            en = s.nextInt();
            d = s.nextInt();
            g.AddEdge(st, en, d);
        }
        g.shortestPath(0, e);
    }
}

4.Graphs_BFS
import java.util.*;

public class Graphs_BFS{
    private int V; // No of vertices
    private LinkedList<Integer> adj[];

    Graphs_BFS(int v){
        V = v;
        adj = new LinkedList[v];
        for(int i = 0; i < v; i++){
            adj[i] = new LinkedList();
        }
    }

    void addEdge(int v, int w){
        adj[v].add(w);
    }

    void BFS(int s){
        boolean visited[] = new boolean[V];

        LinkedList<Integer> queue = new LinkedList<Integer>();

        visited[s] = true;
        queue.add(s);

        while(queue.size() != 0){
            s = queue.poll();
            System.out.print(s + " ");

            Iterator<Integer> i = adj[s].listIterator();
            while(i.hasNext()){
                int n = i.next();
                if(!visited[n]){
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    public static void main(String args[]) {
        Graphs_BFS g = new Graphs_BFS(4);

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        System.out.println("Following is Breadth First Traversal " +
                "(starting from vertex 2)");

        g.BFS(2);
    }
}
5. Graphs_DFS
import java.util.*;

public class Graphs_DFS {
    private int V;
    private LinkedList<Integer> adj[];

    Graphs_DFS(int v){
        V = v;
        adj = new LinkedList[v];
        for (int i = 0; i < v; i++){
            adj[i] = new LinkedList();
        }
    }

    void addEdge(int v, int w){
        adj[v].add(w);
    }

    void DFSUtil(int v, boolean visited[]){
        visited[v] = true;
        System.out.print(v + " ");

        Iterator<Integer> i = adj[v].listIterator();
        while(i.hasNext()){
            int n = i.next();
            if(!visited[v]){
                DFSUtil(n, visited);
            }
        }
    }

    void DFS(int v){
        boolean visited[] = new boolean[V];
        DFSUtil(v, visited);
    }

    public static void main(String args[]) {
        Graphs_DFS g = new Graphs_DFS(4);

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        System.out.println("Following is Depth First Traversal " +
                "(starting from vertex 2)");

        g.DFS(2);
    }
}
6. HeapSort
import java.util.*;

public class HeapSort {
    
    // Method to perform heap sort
    public static void sort(int arr[]) {
        int N = arr.length;
        
        // Build heap (rearrange array)
        for (int i = N / 2 - 1; i >= 0; i--) {
            heapify(arr, N, i);
        }
        
        // One by one extract an element from heap
        for (int i = N - 1; i > 0; i--) {
            // Move current root to end
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            // Call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }
    
    // To heapify a subtree rooted with node i which is an index in arr[]. N is size of heap
    static void heapify(int arr[], int N, int i) {
        int largest = i;    // Initialize largest as root
        int l = 2 * i + 1;  // left = 2*i + 1
        int r = 2 * i + 2;  // right = 2*i + 2
        
        // If left child is larger than root
        if (l < N && arr[l] > arr[largest])
            largest = l;
        
        // If right child is larger than largest so far
        if (r < N && arr[r] > arr[largest])
            largest = r;
        
        // If largest is not root
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;
            
            // Recursively heapify the affected sub-tree
            heapify(arr, N, largest);
        }
    }
    
    public static void main(String args[]) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();  // Input size of array
        int arr[] = new int[n];  // Array to store elements
        
        // Input elements of the array
        for (int i = 0; i < n; i++)
            arr[i] = s.nextInt();
        
        sort(arr);  // Sort the array using heap sort
        
        System.out.println("Sorted array is");
        
        // Print the sorted array
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + " ");
        
        System.out.println();  // Move to next line
    }
}
7. Recover BST

import java.util.Stack;

class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode() {}
    
    TreeNode(int val){
        this.val = val;
    }
    
    TreeNode(int val, TreeNode left, TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}


class Solution{
    public void recoverbst(TreeNode root){
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        TreeNode lastProcessed = null;
        TreeNode[] swapped = new TreeNode[2];

        while (!stack.isEmpty() || current != null){
            
            while (current != null){
                stack.push(current);
                current = current.left;
            }

            current = stack.pop();
            if (lastProcessed != null && lastProcessed.val > current.val){
                if (swapped[0] == null){
                    swapped[0] = lastProcessed;
                    swapped[1] = current;
                }
                else{
                    swapped[1] = current;
                    break;
                }
            }
            lastProcessed = current;
            current = current.right;
        }
    }
}

public class Recover_BST{
    public static void main(String args[]){
     
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(1);
        root.right = new TreeNode(4);
        root.right.left = new TreeNode(2);

        Solution solution = new Solution();
        solution.recoverbst(root);

        printInorder(root);

    }

    static void printInorder(TreeNode node){
        if (node == null){
            return;
        }
        printInorder(node.left);
        System.out.println(" " + node.val);
        printInorder(node.right);
    }
}

8. Topological sort
import java.util.*;

class TopologicalSort {
    // Graph coloring: 0->not visited...1->visited...2->visited & processed
    private boolean detectCycleUtil(List<List<Integer>> adj, int[] visited, int v) {
        if (visited[v] == 1)
            return true;
        if (visited[v] == 2)
            return false;

        visited[v] = 1; // Mark current as visited
        for (int i = 0; i < adj.get(v).size(); ++i)
            if (detectCycleUtil(adj, visited, adj.get(v).get(i)))
                return true;

        visited[v] = 2; // Mark current node as processed
        return false;
    }

    // Cycle detection
    private boolean detectCycle(List<List<Integer>> adj, int n) {
        int[] visited = new int[n];
        for (int i = 0; i < n; ++i)
            if (visited[i] == 0)
                if (detectCycleUtil(adj, visited, i))
                    return true;
        return false;
    }

    // Topological sort
    private void dfs(List<List<Integer>> adj, int v, boolean[] visited, Stack<Integer> mystack) {
        visited[v] = true;
        for (int i = 0; i < adj.get(v).size(); ++i)
            if (!visited[adj.get(v).get(i)])
                dfs(adj, adj.get(v).get(i), visited, mystack);

        mystack.push(v);
    }

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < numCourses; i++)
            adj.add(new ArrayList<>());

        for (int i = 0; i < prerequisites.length; ++i)
            adj.get(prerequisites[i][1]).add(prerequisites[i][0]);

        int[] ans = new int[numCourses];
        if (detectCycle(adj, numCourses))
            return new int[0];

        Stack<Integer> mystack = new Stack<>();
        boolean[] visited = new boolean[numCourses];

        for (int i = 0; i < numCourses; ++i)
            if (!visited[i])
                dfs(adj, i, visited, mystack);

        int index = 0;
        while (!mystack.isEmpty()) {
            ans[index++] = mystack.pop();
        }
        return ans;
    }

    public static void main(String[] args) {
        TopologicalSort solution = new TopologicalSort();
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of courses: ");
        int numCourses = scanner.nextInt();

        System.out.print("Enter the number of prerequisites: ");
        int n = scanner.nextInt();
        int[][] prerequisites = new int[n][2];

        System.out.println("Enter prerequisite pairs (course, prerequisite):");
        for (int i = 0; i < n; i++) {
            prerequisites[i][0] = scanner.nextInt();
            prerequisites[i][1] = scanner.nextInt();
        }

        int[] result = solution.findOrder(numCourses, prerequisites);
        System.out.println("Topological order of courses:");
        System.out.println(Arrays.toString(result));
    }
}

9. Vertical order traversal
import java.util.*;
import java.util.Map.Entry;

class Node{
    int data;
    Node left, right;

    public Node(int data){
        this.data = data;
        left = right = null;
    }
}

public class Vertical_Order_Traversal {
    static Node root;

    static class BinaryTree{
        
        public Node build(String s[]){
            if (s[0].equals("N") || s.length == 0){
                return null;
            }
            Node root = new Node(Integer.parseInt(s[0]));
            Queue<Node> q = new LinkedList<>();
            q.add(root);

            int i = 1;
            while(!q.isEmpty() && i < s.length){
                Node curr = q.poll();
                String cval = s[i];
                if (!cval.equals("N")){
                    int h = Integer.parseInt(cval);
                    curr.left = new Node(h);
                    q.add(curr.left);
                }
                i++;
                if (i >= s.length){
                    break;
                }
                cval = s[i];
                if (!cval.equals("N")){
                    int h = Integer.parseInt(cval);
                    curr.right = new Node(h);
                    q.add(curr.right);
                }
                i++;
            }

            return root;
        }

        static void preOrderTraversal(Node root, long hd, long vd, TreeMap<Long, Vector<Integer>> m){
            if(root == null){
                return;
            }
            long val = hd << 30 | vd;
            if(m.get(val) != null){
                m.get(val).add(root.data);
            }
            else{
                Vector<Integer> v = new Vector<>();
                v.add(root.data);
                m.put(val, v);
            }

            preOrderTraversal(root.left, hd - 1, vd + 1, m);
            preOrderTraversal(root.right, hd + 1, vd + 1, m);
        }

        void verticalOrder(Node root){
            TreeMap<Long, Vector<Integer>> mp = new TreeMap<>();
            preOrderTraversal(root, 0, 1, mp);
            int prekey = Integer.MAX_VALUE;

            for(Entry<Long, Vector<Integer>> entry : mp.entrySet()){
                if(prekey != Integer.MAX_VALUE && (entry.getKey() >> 30 ) != prekey){
                    System.out.println();
                }
                prekey = (int) (entry.getKey() >> 30);
                for(int x : entry.getValue()){
                    System.out.print(x + " ");
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Vertical_Order_Traversal.BinaryTree bt = new Vertical_Order_Traversal.BinaryTree();

        String s[] = sc.nextLine().split(" ");
        root = bt.build(s);
        bt.verticalOrder(root);
    }

}

10. Views of a tree
import java.util.*;

class Node{
    int data, hd;
    Node left, right;

    public Node(int data){
        this.data = data;
        left = right = null;
        this.hd = Integer.MAX_VALUE;
    }
}

public class Views_of_a_Tree {

    static Node root;

    static Node build(String s[]){
        if (s[0].equals("N") || s.length == 0){
            return null;
        }

        Node root = new Node(Integer.parseInt(s[0]));
        Queue<Node> q = new LinkedList<Node>();
        q.add(root);
        int i = 1;

        while(!q.isEmpty() && i < s.length){
            Node curr = q.poll();
            
            String cval = s[i];
            if(!cval.equals("N")){
                int h = Integer.parseInt(cval);
                curr.left = new Node(h);
                q.add(curr.left);
            }
            i++;
            
            if (i >= s.length){
                break;
            }
            
            cval = s[i];
            if (!cval.equals("N")){
                int h = Integer.parseInt(cval);
                curr.right = new Node(h);
                q.add(curr.right);
            }
            i++;
        }
        return root;
    }

    // Right View
    void rightView(Node root){
        if (root == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()){
            int n = q.size();
            for(int i = 0; i < n; i++){
                Node curr = q.peek();
                q.remove();
                if(i == n - 1){
                    System.out.println(curr.data + " ");
                }

                if (curr.left != null){
                    q.add(curr.left);
                }
                
                if(curr.right != null){
                    q.add(curr.right);
                }
            }
        }
    }

    // Left View
    void leftView(Node root){
        if(root == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int n = q.size();
            for (int i = 1; i <= n; i++){
                Node curr = q.poll();
                
                if (i == 1){
                    System.out.print(curr.data + " ");
                }

                if (curr.left != null){
                    q.add(curr.left);
                }

                if (curr.right != null){
                    q.add(curr.right);
                }
            }
        }
    }

    // Top View
    static class QueueObj{
        Node node;
        int hd;

        QueueObj(Node node, int hd){
            this.node = node;
            this.hd = hd;
        }
    }

    static void topView(Node root){
        if (root == null){
            return ;
        }

        Queue<QueueObj> q = new LinkedList<>();
        Map<Integer, Integer> map = new HashMap<>();
        int min = 0;
        int max = 0;

        q.add(new QueueObj(root, 0));
        while (!q.isEmpty()){
            QueueObj curr = q.poll();

            if(!map.containsKey(curr.hd)){
                map.put(curr.hd, curr.node.data);
            }
                
            if(curr.node.left != null){
                min = Math.min(min, curr.hd - 1);
                q.add(new QueueObj(curr.node.left, curr.hd - 1));
            }

            if(curr.node.right != null){
                max = Math.max(max, curr.hd + 1);
                q.add(new QueueObj(curr.node.right, curr.hd + 1));
            }
        }

        for(; min <= max; min++){
            System.out.print(map.get(min) + " ");
        }
    }

    // Bottom View
    static void bottomView(Node root){
        if (root == null){
            return;
        }

        int hd = 0;

        Map<Integer, Integer> map = new TreeMap<>();
        Queue<Node> queue = new LinkedList<Node>();
        root.hd = hd;
        queue.add(root);

        while(!queue.isEmpty()){
            Node temp = queue.remove();
            hd = temp.hd;
            map.put(hd, temp.data);

            if(temp.left != null){
                temp.left.hd = hd - 1;
                queue.add(temp.left);
            }

            if(temp.right != null){
                temp.right.hd = hd + 1;
                queue.add(temp.right);
            }
        }

        for(int value : map.values()){
            System.out.print(value + " ");
        }
    }

    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        Views_of_a_Tree ob = new Views_of_a_Tree();
        String s[] = sc.nextLine().split(" ");
        root = build(s);
        ob.rightView(root);
        System.out.println();
        ob.leftView(root);
        System.out.println();
        topView(root);
        System.out.println();
        bottomView(root);
    }

}

